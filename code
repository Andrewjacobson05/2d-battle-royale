<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Fortnite Battle Royale</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
            color: white;
        }
        
        #gameContainer {
            position: relative;
            border: 2px solid #444;
            background: linear-gradient(45deg, #2d5a27, #4a7c59);
        }
        
        canvas {
            display: block;
            background: linear-gradient(45deg, #2d5a27, #4a7c59);
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            font-size: 14px;
        }
        
        #health {
            background: rgba(255, 0, 0, 0.8);
            padding: 5px 10px;
            border-radius: 3px;
            margin-bottom: 5px;
        }
        
        #ammo {
            background: rgba(0, 100, 255, 0.8);
            padding: 5px 10px;
            border-radius: 3px;
            margin-bottom: 5px;
        }
        
        #players {
            background: rgba(255, 255, 0, 0.8);
            padding: 5px 10px;
            border-radius: 3px;
            color: black;
            margin-bottom: 5px;
        }
        
        #storm {
            background: rgba(128, 0, 128, 0.8);
            padding: 5px 10px;
            border-radius: 3px;
            margin-bottom: 5px;
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 20;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }
        
        button:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="ui">
            <div id="health">Health: 100</div>
            <div id="ammo">Ammo: 30</div>
            <div id="players">Players: 10</div>
            <div id="storm">Storm in: 30s</div>
        </div>
        
        <div id="controls">
            <div><strong>Controls:</strong></div>
            <div>WASD - Move</div>
            <div>Mouse - Aim & Shoot</div>
            <div>E - Pick up loot</div>
            <div>R - Reload</div>
        </div>
        
        <div id="gameOver">
            <h2 id="resultText">Game Over!</h2>
            <p id="resultDetails">You were eliminated!</p>
            <button onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameState = {
            player: {
                x: canvas.width / 2,
                y: canvas.height / 2,
                size: 15,
                health: 100,
                maxHealth: 100,
                speed: 3,
                angle: 0,
                ammo: 30,
                maxAmmo: 30,
                reloading: false,
                reloadTime: 0
            },
            enemies: [],
            bullets: [],
            loot: [],
            storm: {
                x: canvas.width / 2,
                y: canvas.height / 2,
                radius: Math.max(canvas.width, canvas.height),
                targetRadius: 200,
                shrinkSpeed: 0.5,
                damage: 5,
                nextShrink: 30000 // 30 seconds
            },
            keys: {},
            mouse: { x: 0, y: 0, down: false },
            gameRunning: true,
            playersAlive: 10,
            gameTime: 0
        };
        
        // Initialize game
        function init() {
            // Create enemies
            for (let i = 0; i < 9; i++) {
                createEnemy();
            }
            
            // Create initial loot
            for (let i = 0; i < 15; i++) {
                createLoot();
            }
            
            // Start game loop
            gameLoop();
            updateStormTimer();
        }
        
        // Create enemy
        function createEnemy() {
            const enemy = {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: 12,
                health: 80,
                maxHealth: 80,
                speed: 2,
                angle: Math.random() * Math.PI * 2,
                lastShot: 0,
                shootCooldown: 2000,
                ai: {
                    target: null,
                    lastDirection: Date.now(),
                    moveDirection: Math.random() * Math.PI * 2
                }
            };
            gameState.enemies.push(enemy);
        }
        
        // Create loot
        function createLoot() {
            const types = ['health', 'ammo', 'weapon'];
            const loot = {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                type: types[Math.floor(Math.random() * types.length)],
                size: 8,
                collected: false
            };
            gameState.loot.push(loot);
        }
        
        // Input handling
        document.addEventListener('keydown', (e) => {
            gameState.keys[e.key.toLowerCase()] = true;
            
            if (e.key.toLowerCase() === 'r' && !gameState.player.reloading) {
                reload();
            }
            
            if (e.key.toLowerCase() === 'e') {
                collectLoot();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key.toLowerCase()] = false;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            gameState.mouse.x = e.clientX - rect.left;
            gameState.mouse.y = e.clientY - rect.top;
            
            // Calculate player angle
            const dx = gameState.mouse.x - gameState.player.x;
            const dy = gameState.mouse.y - gameState.player.y;
            gameState.player.angle = Math.atan2(dy, dx);
        });
        
        canvas.addEventListener('mousedown', (e) => {
            gameState.mouse.down = true;
        });
        
        canvas.addEventListener('mouseup', (e) => {
            gameState.mouse.down = false;
        });
        
        canvas.addEventListener('click', (e) => {
            if (gameState.gameRunning) {
                shoot(gameState.player);
            }
        });
        
        // Player movement
        function updatePlayer() {
            const player = gameState.player;
            
            // Movement
            if (gameState.keys['w']) player.y -= player.speed;
            if (gameState.keys['s']) player.y += player.speed;
            if (gameState.keys['a']) player.x -= player.speed;
            if (gameState.keys['d']) player.x += player.speed;
            
            // Keep player in bounds
            player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
            player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));
            
            // Handle reloading
            if (player.reloading) {
                player.reloadTime -= 16;
                if (player.reloadTime <= 0) {
                    player.reloading = false;
                    player.ammo = player.maxAmmo;
                }
            }
            
            // Storm damage
            const distFromStormCenter = Math.sqrt(
                Math.pow(player.x - gameState.storm.x, 2) + 
                Math.pow(player.y - gameState.storm.y, 2)
            );
            
            if (distFromStormCenter > gameState.storm.radius) {
                player.health -= gameState.storm.damage * 0.1;
                if (player.health <= 0) {
                    endGame(false);
                }
            }
        }
        
        // Enemy AI
        function updateEnemies() {
            gameState.enemies.forEach((enemy, index) => {
                if (enemy.health <= 0) {
                    gameState.enemies.splice(index, 1);
                    gameState.playersAlive--;
                    return;
                }
                
                // Simple AI
                const now = Date.now();
                const distToPlayer = Math.sqrt(
                    Math.pow(enemy.x - gameState.player.x, 2) + 
                    Math.pow(enemy.y - gameState.player.y, 2)
                );
                
                // Change direction occasionally
                if (now - enemy.ai.lastDirection > 2000) {
                    enemy.ai.moveDirection = Math.random() * Math.PI * 2;
                    enemy.ai.lastDirection = now;
                }
                
                // Move towards storm center if outside
                const distFromStorm = Math.sqrt(
                    Math.pow(enemy.x - gameState.storm.x, 2) + 
                    Math.pow(enemy.y - gameState.storm.y, 2)
                );
                
                if (distFromStorm > gameState.storm.radius - 50) {
                    enemy.ai.moveDirection = Math.atan2(
                        gameState.storm.y - enemy.y,
                        gameState.storm.x - enemy.x
                    );
                }
                
                // Movement
                enemy.x += Math.cos(enemy.ai.moveDirection) * enemy.speed;
                enemy.y += Math.sin(enemy.ai.moveDirection) * enemy.speed;
                
                // Keep in bounds
                enemy.x = Math.max(enemy.size, Math.min(canvas.width - enemy.size, enemy.x));
                enemy.y = Math.max(enemy.size, Math.min(canvas.height - enemy.size, enemy.y));
                
                // Shoot at player if close enough
                if (distToPlayer < 150 && now - enemy.lastShot > enemy.shootCooldown) {
                    enemy.angle = Math.atan2(
                        gameState.player.y - enemy.y,
                        gameState.player.x - enemy.x
                    );
                    shoot(enemy);
                    enemy.lastShot = now;
                }
                
                // Storm damage
                if (distFromStorm > gameState.storm.radius) {
                    enemy.health -= gameState.storm.damage * 0.1;
                }
            });
        }
        
        // Shooting
        function shoot(shooter) {
            if (shooter === gameState.player) {
                if (gameState.player.reloading || gameState.player.ammo <= 0) return;
                gameState.player.ammo--;
            }
            
            const bullet = {
                x: shooter.x,
                y: shooter.y,
                angle: shooter.angle,
                speed: 8,
                size: 3,
                owner: shooter,
                damage: 25
            };
            
            gameState.bullets.push(bullet);
        }
        
        // Reload
        function reload() {
            if (gameState.player.ammo < gameState.player.maxAmmo) {
                gameState.player.reloading = true;
                gameState.player.reloadTime = 2000; // 2 seconds
            }
        }
        
        // Update bullets
        function updateBullets() {
            gameState.bullets.forEach((bullet, bulletIndex) => {
                // Move bullet
                bullet.x += Math.cos(bullet.angle) * bullet.speed;
                bullet.y += Math.sin(bullet.angle) * bullet.speed;
                
                // Remove if out of bounds
                if (bullet.x < 0 || bullet.x > canvas.width || 
                    bullet.y < 0 || bullet.y > canvas.height) {
                    gameState.bullets.splice(bulletIndex, 1);
                    return;
                }
                
                // Check collision with player
                if (bullet.owner !== gameState.player) {
                    const distToPlayer = Math.sqrt(
                        Math.pow(bullet.x - gameState.player.x, 2) + 
                        Math.pow(bullet.y - gameState.player.y, 2)
                    );
                    
                    if (distToPlayer < gameState.player.size) {
                        gameState.player.health -= bullet.damage;
                        gameState.bullets.splice(bulletIndex, 1);
                        
                        if (gameState.player.health <= 0) {
                            endGame(false);
                        }
                        return;
                    }
                }
                
                // Check collision with enemies
                if (bullet.owner === gameState.player) {
                    gameState.enemies.forEach((enemy, enemyIndex) => {
                        const distToEnemy = Math.sqrt(
                            Math.pow(bullet.x - enemy.x, 2) + 
                            Math.pow(bullet.y - enemy.y, 2)
                        );
                        
                        if (distToEnemy < enemy.size) {
                            enemy.health -= bullet.damage;
                            gameState.bullets.splice(bulletIndex, 1);
                            
                            if (enemy.health <= 0) {
                                // Create loot drop
                                createLootAt(enemy.x, enemy.y);
                            }
                        }
                    });
                }
            });
        }
        
        // Create loot at position
        function createLootAt(x, y) {
            const types = ['health', 'ammo'];
            const loot = {
                x: x,
                y: y,
                type: types[Math.floor(Math.random() * types.length)],
                size: 8,
                collected: false
            };
            gameState.loot.push(loot);
        }
        
        // Collect loot
        function collectLoot() {
            gameState.loot.forEach((loot, index) => {
                if (loot.collected) return;
                
                const dist = Math.sqrt(
                    Math.pow(loot.x - gameState.player.x, 2) + 
                    Math.pow(loot.y - gameState.player.y, 2)
                );
                
                if (dist < 25) {
                    loot.collected = true;
                    
                    switch (loot.type) {
                        case 'health':
                            gameState.player.health = Math.min(
                                gameState.player.maxHealth,
                                gameState.player.health + 25
                            );
                            break;
                        case 'ammo':
                            gameState.player.ammo = Math.min(
                                gameState.player.maxAmmo,
                                gameState.player.ammo + 15
                            );
                            break;
                    }
                    
                    gameState.loot.splice(index, 1);
                }
            });
        }
        
        // Update storm
        function updateStorm() {
            if (gameState.storm.radius > gameState.storm.targetRadius) {
                gameState.storm.radius -= gameState.storm.shrinkSpeed;
            }
        }
        
        // Storm timer
        function updateStormTimer() {
            if (!gameState.gameRunning) return;
            
            gameState.storm.nextShrink -= 1000;
            
            if (gameState.storm.nextShrink <= 0) {
                gameState.storm.targetRadius = Math.max(50, gameState.storm.targetRadius - 50);
                gameState.storm.nextShrink = 20000; // Next shrink in 20 seconds
                gameState.storm.shrinkSpeed += 0.2;
            }
            
            setTimeout(updateStormTimer, 1000);
        }
        
        // Render game
        function render() {
            // Clear canvas
            ctx.fillStyle = 'rgba(45, 90, 39, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw storm
            ctx.strokeStyle = 'rgba(128, 0, 128, 0.8)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(gameState.storm.x, gameState.storm.y, gameState.storm.radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Fill outside storm with purple tint
            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = 'rgba(128, 0, 128, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.globalCompositeOperation = 'destination-out';
            ctx.beginPath();
            ctx.arc(gameState.storm.x, gameState.storm.y, gameState.storm.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Draw loot
            gameState.loot.forEach(loot => {
                let color;
                switch (loot.type) {
                    case 'health': color = '#ff4444'; break;
                    case 'ammo': color = '#4444ff'; break;
                    case 'weapon': color = '#ffaa00'; break;
                }
                
                ctx.fillStyle = color;
                ctx.fillRect(loot.x - loot.size/2, loot.y - loot.size/2, loot.size, loot.size);
                
                // Glow effect
                ctx.shadowColor = color;
                ctx.shadowBlur = 10;
                ctx.fillRect(loot.x - loot.size/2, loot.y - loot.size/2, loot.size, loot.size);
                ctx.shadowBlur = 0;
            });
            
            // Draw enemies
            gameState.enemies.forEach(enemy => {
                // Body
                ctx.fillStyle = '#ff6666';
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Health bar
                const barWidth = enemy.size * 2;
                const barHeight = 4;
                const healthPercent = enemy.health / enemy.maxHealth;
                
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.size - 10, barWidth, barHeight);
                
                ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.size - 10, barWidth * healthPercent, barHeight);
                
                // Weapon direction
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(enemy.x, enemy.y);
                ctx.lineTo(
                    enemy.x + Math.cos(enemy.angle) * (enemy.size + 8),
                    enemy.y + Math.sin(enemy.angle) * (enemy.size + 8)
                );
                ctx.stroke();
            });
            
            // Draw player
            ctx.fillStyle = '#4444ff';
            ctx.beginPath();
            ctx.arc(gameState.player.x, gameState.player.y, gameState.player.size, 0, Math.PI * 2);
            ctx.fill();
            
            // Player weapon
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(gameState.player.x, gameState.player.y);
            ctx.lineTo(
                gameState.player.x + Math.cos(gameState.player.angle) * (gameState.player.size + 10),
                gameState.player.y + Math.sin(gameState.player.angle) * (gameState.player.size + 10)
            );
            ctx.stroke();
            
            // Draw bullets
            gameState.bullets.forEach(bullet => {
                ctx.fillStyle = bullet.owner === gameState.player ? '#ffff00' : '#ff0000';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Update UI
            document.getElementById('health').textContent = `Health: ${Math.max(0, Math.floor(gameState.player.health))}`;
            document.getElementById('ammo').textContent = `Ammo: ${gameState.player.ammo}${gameState.player.reloading ? ' (Reloading...)' : ''}`;
            document.getElementById('players').textContent = `Players: ${gameState.playersAlive}`;
            document.getElementById('storm').textContent = `Storm in: ${Math.floor(gameState.storm.nextShrink / 1000)}s`;
        }
        
        // Game loop
        function gameLoop() {
            if (!gameState.gameRunning) return;
            
            updatePlayer();
            updateEnemies();
            updateBullets();
            updateStorm();
            render();
            
            // Check win condition
            if (gameState.enemies.length === 0) {
                endGame(true);
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // End game
        function endGame(won) {
            gameState.gameRunning = false;
            const gameOverDiv = document.getElementById('gameOver');
            const resultText = document.getElementById('resultText');
            const resultDetails = document.getElementById('resultDetails');
            
            if (won) {
                resultText.textContent = 'Victory Royale!';
                resultDetails.textContent = 'Congratulations! You are the last player standing!';
            } else {
                resultText.textContent = 'Game Over!';
                resultDetails.textContent = `You finished in position #${gameState.playersAlive + 1}`;
            }
            
            gameOverDiv.style.display = 'block';
        }
        
        // Restart game
        function restartGame() {
            // Reset game state
            gameState = {
                player: {
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    size: 15,
                    health: 100,
                    maxHealth: 100,
                    speed: 3,
                    angle: 0,
                    ammo: 30,
                    maxAmmo: 30,
                    reloading: false,
                    reloadTime: 0
                },
                enemies: [],
                bullets: [],
                loot: [],
                storm: {
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    radius: Math.max(canvas.width, canvas.height),
                    targetRadius: 200,
                    shrinkSpeed: 0.5,
                    damage: 5,
                    nextShrink: 30000
                },
                keys: {},
                mouse: { x: 0, y: 0, down: false },
                gameRunning: true,
                playersAlive: 10,
                gameTime: 0
            };
            
            document.getElementById('gameOver').style.display = 'none';
            init();
        }
        
        // Start the game
        init();
    </script>
</body>
</html>
